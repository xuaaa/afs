<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>note22 </title>
    <link rel="stylesheet" type="text/css" href="../css/nav.css">
    <link rel="stylesheet" type="text/css" href="note22.css">
</head>

<body>
    <!-- title -->
    <div class="title">
        <div class="tit">
            <h1>第二十二天笔记</h1>
        </div>
    </div>
    <!-- main -->
    <div class="wapper">
        <div class="main">
            <!--  -->
            <h2>正则表达式</h2>
            <div class="main-top">
                <h4>js中使用正则表达式，除了了解正则表达式基本的匹配规则外。还需要了解下面的基本的知识</h4>
                <p>var reg = new RegExp('\\d{8-20}')</p>
                <p>reg.test(“11111111a”)</p>
                <p class="grenn"> 这里的\\，第一个\是转义符，用于转义。</p>
                <p class="grenn">上面的例子还可以写成：</p>
                <p>var reg = new RegExp(/\d{8-20}/) </p>
                <p>reg.test(“11111111a”)</p>
                <p class="grenn"> test可以测试字符串是否匹配正则表达是的规则，exec、match用于捕获匹配的子串。</p>
            </div>
            <!-- 什么是正则表达式 -->
            <div class="main-two">
                <h2>什么是正则表达式：</h2>
                <ol>
                    <li>正则表达式(regular expression)描述了一种字符串匹配的模式，可以用来检查一个字符串是否含有某种子串、将匹配的子串做替换或者从某个字符串中取出符合某个条件的子串等。</li>
                    <li>说白了正则表达式就是处理字符串的,我们可以用它来处理一些复杂的字符串。</li>
                </ol>
                <h3>为什么要学习正则表达式</h3>
               
                <div class="daima">
                    <p>例：</p>
                    <span> //找出这个字符串中的所有数字</span>
                    <span> var str = 'abc123de45fgh6789qqq111';</span>
                    <span> //方法1</span>
                    <span class="suojin"> function findNum(str{</span>
                    <span class="suojin"> var tmp = '',</span>
                    <span class="suojin3"> arr = [];</span>
                    <span class="suojin"> for (var i = 0; i < str.length; i++) {&ltstr.length></span>
                    <span class="suojin"> var cur = str[i];</span>
                    <span class="suojin"> if (!isNaN(cur)) {</span>
                    <span class="suojin3"> tmp += cur;</span>
                    <span class="suojin"> } else {</span>
                    <span class="suojin3"> if (tmp) {</span>
                    <span class="suojin3"> arr.push(tmp);</span>
                    <span class="suojin3"> tmp = '';</span>
                    <span class="suojin3"> }</span>
                    <span class="suojin"> }</span>
                    <span class="suojin"> }</span>
                    <span class="suojin"> if (tmp) {</span>
                    <span class="suojin3"> arr.push(tmp)</span>
                    <span class="suojin"> }</span>
                    <span class="suojin3"> return arr;</span>
                    <span class="suojin"> }</span>
                    <span> console.log(findNum(str))</span>
                    <span> //["123", "45", "6789", "111"]</span>

                    <span> //方法2 使用正则表达式</span>
                    <span>var reg = /\d+/g;</span>
                    <span> console.log(str.match(reg))</span>
                    <span>  // ["123", "45", "6789", "111"]</span>
                </div>
                <p>通过比较2种方法我们明显看出在对字符串进行处理时，使用正则表达式会简单许多，
                    所以虽然正则表达式看起来像是火星文一样的一堆乱码的东西，但我们还是有必要去学习它的。</p>
            </div>
            <!-- 正则表达式创建方式 -->
            <div class="mainthree">
                <h2>正则表达式创建方式</h2>
                <ol>
                    <li>1.字面量创建方式</li>
                    <li>2.实例创建方式</li>
                </ol>
                <div class="daima">
                    <span> var reg = /pattern/flags</span>
                    <span class="grenn"> // 字面量创建方式</span>
                    <span> var reg = new RegExp(pattern,flags);</span>
                    <span class="grenn"> //实例创建方式</span>

                    <span class="grenn"> pattern:正则表达式 </span>
                    <span class="grenn"> flags:标识(修饰符)</span>
                    <span class="grenn"> 标识主要包括：</span>
                    <span class="grenn"> 1. i 忽略大小写匹配</span>
                    <span class="grenn"> 2. m 多行匹配，即在到达一行文本末尾时还会继续寻常下一行中是否与正则匹配的项</span>
                    <span class="grenn">3. g 全局匹配 模式应用于所有字符串，而非在找到第一个匹配项时停止</span>
                </div>
                <!-- 字面量创建方式和构造函数创建方式的区别 -->
                <h4>字面量创建方式和构造函数创建方式的区别</h4>
                <h5>1.字面量创建方式不能进行字符串拼接，实例创建方式可以</h5>
                <div class="daima">
                    <span> var regParam = 'cm';</span>
                    <span> var reg1 = new RegExp(regParam+'1');</span>
                    <span> var reg2 = /regParam/;</span>
                    <span> console.log(reg1); <em>// /cm1/</em></span>
                    <span> console.log(reg2);<em> // /regParam/</em></span>
                </div>
                <h5>2.字面量创建方式特殊含义的字符不需要转义，实例创建方式需要转义</h5>
                <div class="daima">
                    <span> var reg1 = new RegExp('\d'); <em> // /d/</em></span>
                    <span> var reg2 = new RegExp('\\d') <em>// /\d/</em></span>
                    <span> var reg3 = /\d/; <em>// /\d/</em></span>
                </div>
                <!-- 元字符 -->
                <div class="yuanzifumapper">
                <h2>元字符</h2>
                <p>代表特殊含义的元字符:</p>
                <div class="yuanzifu">
                    <p> \d : 0-9之间的任意一个数字 \d只占一个位置</p>
                    <p>\w : 数字，字母 ，下划线 0-9 a-z A-Z _</p>
                    <p> \s : 空格或者空白等</p>
                    <p> \D : 除了\d</p>
                    <p> \W : 除了\w</p>
                    <p>\S : 除了\s</p>
                    <p> . : 除了\n之外的任意一个字符</p>
                    <p> \ : 转义字符</p>
                    <p> | : 或者</p>
                    <p> () : 分组</p>
                    <p> \n : 匹配换行符</p>
                    <p> \b : 匹配边界 字符串的开头和结尾 空格的两边都是边界 => 不占用字符串位数</p>
                    <p> ^ : 限定开始位置 => 本身不占位置</p>
                    <p> $ : 限定结束位置 => 本身不占位置</p>
                    <p> [a-z] : 任意字母 []中的表示任意一个都可以</p>
                    <p> [^a-z] : 非字母 []中^代表除了</p>
                    <p> [abc] : abc三个字母中的任何一个 [^abc]除了这三个字母中的任何一个字符</p>
                </div>
                <!-- 代表次数的量词元字符 -->
               <h4>代表次数的量词元字符</h4>
                <div class="zifulaingci">
                    <p>* : 0到多个</p>
                    <p>+ : 1到多个</p>
                    <p>? : 0次或1次 可有可无</p>
                    <p> {n} : 正好n次</p>
                    <p> {n,} : n到多次</p>
                    <p> {n,m} : n次到m次</p>
                </div>
                <p>量词出现在元字符后面 如\d+，限定出现在前面的元字符的次数</p>
                <div class="daima">
                    <span> var str = '1223334444';</span>
                    <span> var reg = /\d{2}/g;</span>
                    <span> var res = str.match(reg);</span>
                    <span>console.log(res) //["12", "23", "33", "44", "44"]</span>

                    <span> var str =' 我是空格君 ';</span>
                    <span> var reg = /^\s+|\s+$/g; //匹配开头结尾空格</span>
                    <span> var res = str.replace(reg,'');</span>
                    <span> console.log('('+res+')') //(我是空格君)</span>
                </div>
                <p>正则中的()和[]和重复子项 //拿出来单独说一下</p>
                <h5>一般[]中的字符没有特殊含义 如+就表示+<br>
                但是像\w这样的还是有特殊含义的</h5>
                <div class="daima">
                    <span> var str1 = 'abc';</span>
                    <span>var str2 = 'dbc';</span>
                    <span> var str3 = '.bc';</span>
                    <span> var reg = /[ab.]bc/; //此时的.就表示.</span>
                    <span> reg.test(str1) //true</span>
                    <span> reg.test(str2) //false</span>
                    <span> reg.test(str3) //true</span>
                </div>
                <h5>[]中，不会出现两位数</h5>
                <div class="daima">
                    <span> [12]表示1或者2 ,不过[0-9]这样的表示0到9 ,[a-z]表示a到z</span>
                    <span> 例如:匹配从18到65年龄段所有的人</span>
                    <span> var reg = /[18-65]/; // 这样写对么</span>
                    <span> reg.test('50')</span>
                    <span> //Uncaught SyntaxError: Invalid regular expression: /[18-65]/: Range out of order in
                        character class</span>
                    <span class="blue"> //聪明的你想可能是8-6这里不对，于是改成[16-85]似乎可以匹配16到85的年龄段的，但实际上发现这也是不靠谱的</span>

                    <span class="blue"> 实际上我们匹配这个18-65年龄段的正则我们要拆开来匹配</span>
                    <span class="blue"> 我们拆成3部分来匹配 18-19 20-59 60-65</span>
                    <span class="blue">reg = /(18|19)|([2-5]\d)|(6[0-5])/;</span>
                </div>
                <h5>()的提高优先级功能:凡是有|出现的时候，我们一定要注意是否有必要加上()来提高优先级；</h5>
                <h6>()的分组 重复子项 (两个放到一起说)</h6>
                <div class="daima">
                    <span> 分组：</span>
                    <span> 只要正则中出现了小括号那么就会形成一份分组</span>
                    <span> 只要有分组，exec(match)和replace中的结果就会发生改变(后边的正则方法中再说)</span>

                    <span> 分组的引用(重复子项) :</span>
                    <span> 只要在正则中出现了括号就会形成一个分组，我们可以通过\n (n是数字代表的是第几个分组)来引用这个分组，第一个小分组我们可以用\1来表示</span>

                    <span> 例如：求出这个字符串'abAAbcBCCccdaACBDDabcccddddaab'中出现最多的字母,并求出出现多少次(忽略大小写)。
                        var str = 'abbbbAAbcBCCccdaACBDDabcccddddaab';
                        str = str.toLowerCase().split('').sort(function(a,b){return
                        a.localeCompare(b)}).join('');</span>

                    <span class="suojin3 blue"> var reg = /(\w)\1+/ig;</span>
                    <span class="suojin3 blue"> var maxStr = '';</span>
                    <span class="suojin3 blue"> var maxLen = 0;</span>
                    <span class="suojin3 blue"> str.replace(reg,function($0,$1){</span>
                    <span class="suojin3 blue"> var regLen = $0.length;</span>
                    <span class="suojin3 blue"> if(regLen>maxLen){</span>
                    <span class="suojin4 blue">maxLen = regLen;</span>
                    <span class="suojin4 blue"> maxStr = $1;</span>
                    <span class="suojin3 blue"> }else if(maxLen == regLen){</span>
                    <span class="suojin4 blue">maxStr += $1;</span>
                    <span class="suojin3 blue"> }</span>
                    <span class="suojin blue"> })</span>
                    <span class="suojin blue"> console.log(`出现最多的字母是${maxStr},共出现了${maxLen}次`)</span>
                </div>
                <h5>当我们加()只是为了提高优先级而不想捕获小分组时，可以在()中加?:来取消分组的捕获</h5>

                <div class="daima">
                    <span> var str = 'aaabbb';</span>
                    <span> var reg = /(a+)(?:b+)/;</span>
                    <span> var res =reg.exec(str);</span>
                    <span> console.log(res)</span>
                    <span> //["aaabbb", "aaa", index: 0, input: "aaabbb"]</span>
                    <span> //只捕获第一个小分组的内容</span>
                </div>
                </div>
                <!-- 、正则运算符的优先级: -->

                <h2>正则运算符的优先级:</h2>
                <ol>
                    <li>
                        1.正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。
                    </li>
                    <li>相同优先级的会从左到右进行运算，不同优先级的运算先高后低。</li>
                </ol>
                <div class="zhengze">
                    <p> 下面是常见的运算符的优先级排列</p>
                    <p> 依次从最高到最低说明各种正则表达式运算符的优先级顺序：</p>

                    <p> \ : 转义符</p>
                    <p> (), (?:), (?=), [] => 圆括号和方括号</p>
                    <p> *, +, ?, {n}, {n,}, {n,m} => 量词限定符</p>
                    <p> ^, $, \任何元字符、任何字符</p>
                    <p> | => 替换，"或"操作</p>

                    <p class="red"> 字符具有高于替换运算符的优先级，一般用 | 的时候，为了提高 | 的优先级，我们常用()来提高优先级
                    <p class="red"> 如： 匹配 food或者foot的时候 reg = /foo(t|d)/ 这样来匹配
                </div>
                <!-- 正则的特性 -->
                <h3>正则的特性</h3>
                <ol>
                    <li>
                        <h4>贪婪性</h4>
                        <p>所谓的贪婪性就是正则在捕获时，每一次会尽可能多的去捕获符合条件的内容。
                            如果我们想尽可能的少的去捕获符合条件的字符串的话，可以在量词元字符后加?</p>
                    </li>
                    <li>
                        <h4>懒惰性</h4>
                        <p>懒惰性则是正则在成功捕获一次后不管后边的字符串有没有符合条件的都不再捕获。
                            如果想捕获目标中所有符合条件的字符串的话，我们可以用标识符g来标明是全局捕获</p>
                    </li>
                </ol>
                <div class="zhengze">
                    <p> var str = '123aaa456';</p>
                    <p class="red"> var reg = /\d+/; //只捕获一次,一次尽可能多的捕获</p>
                    <p class="red"> var res = str.match(reg)</p>
                    <p class="red"> console.log(res)</p>
                    <p class="red"> // ["123", index: 0, input: "123aaa456"]</p>
                    <p class="red"> res = str.match(reg)</p>
                    <p class="red">console.log(res)</p>
                    <p class="red">// ["1", "2", "3", "4", "5", "6"]</p>
                </div>
                <!-- 和正则相关的一些方法 -->
                <h3>和正则相关的一些方法</h3>
                <ol>
                    <li>
                        <h4>reg.test(str) 用来验证字符串是否符合正则 符合返回true 否则返回false</h4>
                        <div class="daima">
                            <span> var str = 'abc';</span>
                            <span> var reg = /\w+/;</span>
                            <span> console.log(reg.test(str)); //true</span>
                        </div>
                    </li>
                    <li>
                        <h4>reg.exec() 用来捕获符合规则的字符串</h4>
                        <div class="daima">
                            <span> var str = 'abc123cba456aaa789';</span>
                            <span class="red"> var reg = /\d+/;</span>
                            <span> console.log(reg.exec(str))</span>
                            <span class="red"> // ["123", index: 3, input: "abc123cba456aaa789"];</span>
                            <span> console.log(reg.lastIndex)</span>
                            <span> // lastIndex : 0 </span>

                            <span> reg.exec捕获的数组中 </span>
                            <span> // [0:"123",index:3,input:"abc123cba456aaa789"]</span>
                            <span class="red"> 0:"123" 表示我们捕获到的字符串</span>
                            <span class="red"> index:3 表示捕获开始位置的索引</span>
                            <span> input 表示原有的字符串</span>
                        </div>
                        <h4>当我们用exec进行捕获时，如果正则没有加'g'标识符，则exec捕获的每次都是同一个，
                            当正则中有'g'标识符时 捕获的结果就不一样了,我们还是来看刚刚的例子</h4>
                        <div class="daima">
                            <span> var str = 'abc123cba456aaa789';</span>
                            <span>var reg = /\d+/g; //此时加了标识符g</span>
                            <span>console.log(reg.lastIndex)</span>
                            <span class="grenn">// lastIndex : 0</span>
                            <br>
                            <br>
                            <br>
                            <span> console.log(reg.exec(str))</span>
                            <span class="grenn">// ["123", index: 3, input: "abc123cba456aaa789"]</span>
                            <span> console.log(reg.lastIndex)</span>
                            <span class="grenn" // lastIndex : 6</span>
                                <br>
                                <br>
                                <br>
                                <span> console.log(reg.exec(str))</span>
                                <span class="grenn">// ["456", index: 9, input: "abc123cba456aaa789"]</span>
                                <span> console.log(reg.lastIndex)</span>
                                <span class="grenn">// lastIndex : 12</span>
                                <br>
                                <br>
                                <br>
                                <span> console.log(reg.exec(str))</span>
                                <span class="grenn">// ["789", index: 15, input: "abc123cba456aaa789"]</span>
                                <span> console.log(reg.lastIndex)</span>
                                <span class="grenn">// lastIndex : 18</span>
                                <br>
                                <br>
                                <br>
                                <span> console.log(reg.exec(str))</span>
                                <span class="grenn"> // null</span>
                                <span> console.log(reg.lastIndex)</span>
                                <span class="grenn">// lastIndex : 0</span>
                                <br>
                                <br>
                                <br>
                                <span class="grenn"> 每次调用exec方法时,捕获到的字符串都不相同</span>
                                <span class="grenn"> lastIndex ：这个属性记录的就是下一次捕获从哪个索引开始。</span>
                                <span class="grenn"> 当未开始捕获时，这个值为0。</span>
                                <span class="grenn"> 如果当前次捕获结果为null。那么lastIndex的值会被修改为0.下次从头开始捕获。</span>
                                <span class="grenn"> 而且这个lastIndex属性还支持人为赋值。</span>
                        </div>
                        <h4>exec的捕获还受分组()的影响</h4>
                        <div class="daima">
                            <span class="red"> var str = '2017-01-05';</span>
                            <span class="red"> var reg = /-(\d+)/g</span>
                            <span class="red"> // ["-01", "01", index: 4, input: "2017-01-05"]</span>
                            <span class="red">"-01" : 正则捕获到的内容</span>
                            <span class="red">"01" : 捕获到的字符串中的小分组中的内容</span>
                        </div>
                    </li>
                    <li>
                        <h3>str.match(reg) 如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回null</h3>
                        <div class="daima">
                            <span> //match和exec的用法差不多</span>
                            <span> var str = 'abc123cba456aaa789';</span>
                            <span class="red">var reg = /\d+/;</span>
                            <span> console.log(reg.exec(str));</span>
                            <span class="red">//["123", index: 3, input: "abc123cba456aaa789"]</span>
                            <span> console.log(str.match(reg));</span>
                            <span class="red">//["123", index: 3, input: "abc123cba456aaa789"]</span>
                        </div>
                        <h5>上边两个方法console的结果有什么不同呢？二个字符串是一样滴。
                            当我们进行全局匹配时，二者的不同就会显现出来了.</h5>
                        <div class="daima">
                            <span>var str = 'abc123cba456aaa789';</span>
                            <span class="red"> var reg = /\d+/g;</span>
                            <span> console.log(reg.exec(str));</span>
                            <span class="red"> // ["123", index: 3, input: "abc123cba456aaa789"]</span>
                            <span>console.log(str.match(reg));</span>
                            <span class="red"> // ["123", "456", "789"]</span>
                        </div>
                        <h5>当全局匹配时，match方法会一次性把符合匹配条件的字符串全部捕获到数组中,
                            如果想用exec来达到同样的效果需要执行多次exec方法。</h5>
                        <h4>我们可以尝试着用exec来简单模拟下match方法的实现。</h4>
                        <div class="daima">
                            <span> String.prototype.myMatch = function (reg) {</span>
                            <span class="suojin"> var arr = [];</span>
                            <span class="suojin"> var res = reg.exec(this);</span>
                            <span class="suojin"> if (reg.global) {</span>
                            <span> while (res) {</span>
                            <span class="suojin3"> arr.push(res[0]);</span>
                            <span class="suojin3"> res = reg.exec(this)</span>
                            <span> }</span>
                            <span class="suojin"> }else{</span>
                            <span class="suojin3"> arr.push(res[0]);</span>
                            <span class="suojin"> }</span>
                            <span class="suojin"> return arr;</span>
                            <span> }</span>
                            <br>
                            <br>
                            <span> var str = 'abc123cba456aaa789';</span>
                            <span> var reg = /\d+/;</span>
                            <span> console.log(str.myMatch(reg))</span>
                            <span> // ["123"]</span>

                            <span> var str ='abc123cba456aaa789';</span>
                            <span> var reg =/\d+/g;</span>
                            <span>console.log(str.myMatch(reg))</span>
                            <span> // ["123","456", "789"]</span>
                        </div>
                        <h4>此外，match和exec都可以受到分组()的影响，不过match只在没有标识符g的情况下才显示小分组的内容，如果有全局g，则match会一次性全部捕获放到数组中</h4>
                        <div class="daima">
                            <span> var str = 'abc';</span>
                            <span> var reg = /(a)(b)(c)/;</span>
                            <br>
                            <br>
                            <span> console.log( str.match(reg) );</span>
                            <span> // ["abc", "a", "b", "c", index: 0, input: "abc"]</span>
                            <span> console.log( reg.exec(str) );</span>
                            <span> // ["abc", "a", "b", "c", index: 0, input: "abc"]</span>

                            <br>
                            <br>
                            <span> 当有全局g的情况下</span>
                            <span> var str = 'abc';</span>
                            <span> var reg = /(a)(b)(c)/g;</span>
                            <span> console.log( str.match(reg) );</span>
                            <span> // ["abc"]</span>
                            <span> console.log( reg.exec(str) );</span>
                            <span> // ["abc", "a", "b", "c", index: 0, input: "abc"]</span>
                        </div>
                    </li>
                    <li>
                        <h3>str.replace() 这个方法大家肯定不陌生，现在我们要说的就是和这个方法和正则相关的东西了。</h3>
                        <div class="daima">
                            <span> 正则去匹配字符串，匹配成功的字符去替换成新的字符串</span>
                            <span> 写法：str.replace(reg,newStr);</span>
                            <br>
                            <span> var str = 'a111bc222de';</span>
                            <span> var res = str.replace(/\d/g,'Q')</span>
                            <span> console.log(res)</span>
                            <span> // "aQQQbcQQQde"</span>
                            <br>
                            <span> replace的第二个参数也可以是一个函数</span>
                            <span> str.replace(reg,fn);</span>
                            <br>
                            <span> var str = '2017-01-06';</span>
                            <span> str = str.replace(/-\d+/g,function(){</span>
                            <span> console.log(arguments)</span>
                            })
                            <br>
                            <span> 控制台打印结果：</span>
                            <span> ["-01", 4, "2017-01-06"]</span>
                            <span> ["-06", 7, "2017-01-06"]</span>
                            <span> "2017undefinedundefined"</span>
                            <span> 从打印结果我们发现每一次输出的值似乎跟exec捕获时很相似，既然与exec似乎很相似，那么似乎也可以打印出小分组中的内容喽</span>
                            <br>
                            <span> var str = '2017-01-06';</span>
                            <span class="red">str = str.replace(/-(\d+)/g,function(){</span>
                            <span> console.log(arguments)</span>
                            <span> })</span>
                            <span class="red"> ["-01", "01", 4, "2017-01-06"]</span>
                            <span class="red"> ["-06", "06", 7, "2017-01-06"]</span>
                            <span class="red"> "2017undefinedundefined"</span>
                            <span class="red"> 从结果看来我们的猜测没问题。</span>
                            <br>
                            <p class="red"> 此外，我们需要注意的是，如果我们需要替换replace中正则找到的字符串，函数中需要一个返回值去替换正则捕获的内容</p>
                        </div>
                        <h5>通过replace方法获取url中的参数的方法</h5>
                        <div class="daima">
                            <span> (function(pro){</span>
                            <span class="suojin"> function queryString(){</span>
                            <span class="suojin3"> var obj = {},</span>
                            <span class="suojin4"> reg = /([^?&#+]+)=([^?&#+]+)/g;</span>
                            <span class="suojin3">this.replace(reg,function($0,$1,$2){</span>
                            <span class="suojin4"> obj[$1] = $2;</span>
                            <span class="suojin3"> })</span>
                            <span class="suojin3"> return obj;</span>
                            <span class="suojin"> }</span>
                            <span class="suojin"> pro.queryString = queryString;</span>
                            <span> }(String.prototype));</span>

                            <span class="grenn"> // 例如 url为 https://www.baidu.com?a=1&b=2</span>
                            <span class="grenn"> // window.location.href.queryString();</span>
                            <span class="grenn"> // {a:1,b:2}</span>
                        </div>
                    </li>
                </ol>

            </div>
            <!-- 零宽断言 -->
            <!-- <div class="linkuan">
                <h2>零宽断言</h2>
                <p>
                    用于查找在某些内容(但并不包括这些内容)之前或之后的东西，如\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。
                </p>
                <p>在使用正则表达式时，捕获的内容前后必须是特定的内容，而我们又不想捕获这些特定内容的时候，零宽断言就可以派上用场了。</p>
            </div> -->
        </div>
    </div>
       <!-- nav -->
       <div class="fixnav">
        <div class="fixnav-wapper">
            <div class="fixtit">
                <h3 class="fixtitle">学习笔记</h3>
            </div>
            <ul>
                <li><a href="../521-day1/笔记.html">第一天</a></li>
                <li><a href="../521-day2/笔记2.HTML">第二天</a></li>
                <li><a href="../521-day3/笔记3.html">第三天</a></li>
                <li><a href="../521-day4/笔记4.html">第四天</a></li>
                <li><a href="../521-day5/note5.html">第五天</a></li>
                <li><a href="../521-day6/note6.html">第六天</a></li>
                <li><a href="../521-day7/note7.html">第七天</a></li>
                <li><a href="../521-day8/note8.html">第八天</a></li>
                <li><a href="../521-day9/note9.html">第九天</a></li>
                <li><a href="../521-day10/note10.html">第十天</a></li>
                <li><a href="../521-day11/note11.html">第十一天</a></li>
                <li><a href="../521-day12/note12.html">第十二天</a></li>
                <li><a href="../521-day13/note13.html">第十三天</a></li>
                <li><a href="../521-day14/note14.html">第十四天</a></li>
                <li><a href="../521-day15/note15.html">第十五天</a></li>
                <li><a href="../521-day16/note16.html">第十六天</a></li>
                <li><a href="../521-day17/note17.html">第十七天</a></li>
                <li><a href="../521-day18/note18.html">第十八天</a></li>
                <li><a href="../521-day19/note19.html">第十九天</a></li>
                <li><a href="../521-day20/note20.html">第二十天</a></li>
                <li><a href="../521-day21/note21.html">第二十一天</a></li>
                <li><a href="../521-day22/note22.html">第二十二天</a></li>




            </ul>
        </div>
</body>

</html>